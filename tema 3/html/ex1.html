
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ex1</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-03-28"><meta name="DC.source" content="ex1.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%%ex1 pct a</span>

A=[0 1 1;2 1 5; 4 2 1]
b=[3;5;1]
fprintf(<span class="string">'solutia este\n'</span>)
gaussPivTot(A,b);
type(<span class="string">'gaussPivTot'</span>)

<span class="comment">%%ex 1 pct b</span>

A=[0 1 -2;1 -1 1; 1 0 -1]
b=[4;6;2]
fprintf(<span class="string">'solutia este\n'</span>)
gaussPivTot(A,b);
type(<span class="string">'gaussPivTot'</span>)

<span class="comment">%%ex 2 varianta 5</span>

A=matrice(10)
b=solutie(10)
fprintf(<span class="string">'solutia este\n'</span>)
gaussPivTot(A,b);
type(<span class="string">'gaussPivTot'</span>)
<span class="comment">%%ex 3</span>

A=matrice(10)
fprintf(<span class="string">'inversa e\n'</span>)
InvDet(A);
type(<span class="string">'InvDet'</span>)
</pre><pre class="codeoutput">
A =

     0     1     1
     2     1     5
     4     2     1


b =

     3
     5
     1

solutia este
    -1

     2

     1


function [x] = GaussPivTot(A,b)
%GaussPivPart rezolva sisteme patratice

%Synopsis:      x=GaussPivTot(A,b)   

%Input:         A=matricea asociata sistemului
%               b=vectorul termenilor liberi

%Output:        x=solutia sistemului

%-----Verificare matrice patratica
[n,m]=size(A);
if n~=m
    warning('Matricea nu este patratica');
    x=[];
    return
end
%-----Verific daca e vector coloana si daca nu e, il traspunem ca sa fie
[n1,m1]=size(b);
if m1~=1
    b=transpose(b);
end

nr=length(b);

if n~=nr
    warning('Vectorul nu are aceeasi dimensiune cu matricea A')
    x=[];
    return;
end

%construim matricea extinsa

A=[A,b];
for i=1:n
index(i)=i;
end
for k=1:n-1 
    max=-1;
    for i=k:n
        for j=k:n
            if abs(A(i,j))&gt;max;
                max=abs(A(i,j));
                p=i;m=j;
            end
        end
    end
    if A(p,m)==0 
        warning('Sist incomp. sau comp. nedet')
        x=[];
        return
    end
    if p~=k
      A([p,k],:)=A([k,p],:);
    end
      if m~=k
          A(:,[m,k])=A(:,[k,m]);
          index([m,k])=index([k,m]);
      end
      
      for l=k+1:n
          M(l,k)=A(l,k)/A(k,k);
          A(l,:)=A(l,:)-M(l,k)*A(k,:);
      end
end
 
    if A(n,n)==0
        warning('Sist. incomp. sau comp. nedet.');
        return
    end
    y=subsDesc(A(:,1:n),A(:,n+1));
    for j=1:n
            x(index(j))=y(j);
    end
    for i=1:n
        disp(x(i));
    end
end

A =

     0     1    -2
     1    -1     1
     1     0    -1


b =

     4
     6
     2

solutia este
Warning: Sist. incomp. sau comp. nedet. 

function [x] = GaussPivTot(A,b)
%GaussPivPart rezolva sisteme patratice

%Synopsis:      x=GaussPivTot(A,b)   

%Input:         A=matricea asociata sistemului
%               b=vectorul termenilor liberi

%Output:        x=solutia sistemului

%-----Verificare matrice patratica
[n,m]=size(A);
if n~=m
    warning('Matricea nu este patratica');
    x=[];
    return
end
%-----Verific daca e vector coloana si daca nu e, il traspunem ca sa fie
[n1,m1]=size(b);
if m1~=1
    b=transpose(b);
end

nr=length(b);

if n~=nr
    warning('Vectorul nu are aceeasi dimensiune cu matricea A')
    x=[];
    return;
end

%construim matricea extinsa

A=[A,b];
for i=1:n
index(i)=i;
end
for k=1:n-1 
    max=-1;
    for i=k:n
        for j=k:n
            if abs(A(i,j))&gt;max;
                max=abs(A(i,j));
                p=i;m=j;
            end
        end
    end
    if A(p,m)==0 
        warning('Sist incomp. sau comp. nedet')
        x=[];
        return
    end
    if p~=k
      A([p,k],:)=A([k,p],:);
    end
      if m~=k
          A(:,[m,k])=A(:,[k,m]);
          index([m,k])=index([k,m]);
      end
      
      for l=k+1:n
          M(l,k)=A(l,k)/A(k,k);
          A(l,:)=A(l,:)-M(l,k)*A(k,:);
      end
end
 
    if A(n,n)==0
        warning('Sist. incomp. sau comp. nedet.');
        return
    end
    y=subsDesc(A(:,1:n),A(:,n+1));
    for j=1:n
            x(index(j))=y(j);
    end
    for i=1:n
        disp(x(i));
    end
end

A =

    21    -7     0     0     0     0     0     0     0     0
    -7    21    -7     0     0     0     0     0     0     0
     0    -7    21    -7     0     0     0     0     0     0
     0     0    -7    21    -7     0     0     0     0     0
     0     0     0    -7    21    -7     0     0     0     0
     0     0     0     0    -7    21    -7     0     0     0
     0     0     0     0     0    -7    21    -7     0     0
     0     0     0     0     0     0    -7    21    -7     0
     0     0     0     0     0     0     0    -7    21    -7
     0     0     0     0     0     0     0     0    -7    21


b =

     2
     1
     1
     1
     1
     1
     1
     1
     1
     2

solutia este
    0.1429

    0.1429

    0.1429

    0.1429

    0.1429

    0.1429

    0.1429

    0.1429

    0.1429

    0.1429


function [x] = GaussPivTot(A,b)
%GaussPivPart rezolva sisteme patratice

%Synopsis:      x=GaussPivTot(A,b)   

%Input:         A=matricea asociata sistemului
%               b=vectorul termenilor liberi

%Output:        x=solutia sistemului

%-----Verificare matrice patratica
[n,m]=size(A);
if n~=m
    warning('Matricea nu este patratica');
    x=[];
    return
end
%-----Verific daca e vector coloana si daca nu e, il traspunem ca sa fie
[n1,m1]=size(b);
if m1~=1
    b=transpose(b);
end

nr=length(b);

if n~=nr
    warning('Vectorul nu are aceeasi dimensiune cu matricea A')
    x=[];
    return;
end

%construim matricea extinsa

A=[A,b];
for i=1:n
index(i)=i;
end
for k=1:n-1 
    max=-1;
    for i=k:n
        for j=k:n
            if abs(A(i,j))&gt;max;
                max=abs(A(i,j));
                p=i;m=j;
            end
        end
    end
    if A(p,m)==0 
        warning('Sist incomp. sau comp. nedet')
        x=[];
        return
    end
    if p~=k
      A([p,k],:)=A([k,p],:);
    end
      if m~=k
          A(:,[m,k])=A(:,[k,m]);
          index([m,k])=index([k,m]);
      end
      
      for l=k+1:n
          M(l,k)=A(l,k)/A(k,k);
          A(l,:)=A(l,:)-M(l,k)*A(k,:);
      end
end
 
    if A(n,n)==0
        warning('Sist. incomp. sau comp. nedet.');
        return
    end
    y=subsDesc(A(:,1:n),A(:,n+1));
    for j=1:n
            x(index(j))=y(j);
    end
    for i=1:n
        disp(x(i));
    end
end

A =

    21    -7     0     0     0     0     0     0     0     0
    -7    21    -7     0     0     0     0     0     0     0
     0    -7    21    -7     0     0     0     0     0     0
     0     0    -7    21    -7     0     0     0     0     0
     0     0     0    -7    21    -7     0     0     0     0
     0     0     0     0    -7    21    -7     0     0     0
     0     0     0     0     0    -7    21    -7     0     0
     0     0     0     0     0     0    -7    21    -7     0
     0     0     0     0     0     0     0    -7    21    -7
     0     0     0     0     0     0     0     0    -7    21

inversa e
  Columns 1 through 7

    0.0546    0.0208    0.0080    0.0030    0.0012    0.0004    0.0002
    0.0208    0.0625    0.0239    0.0091    0.0035    0.0013    0.0005
    0.0080    0.0239    0.0637    0.0243    0.0093    0.0035    0.0014
    0.0030    0.0091    0.0243    0.0639    0.0244    0.0093    0.0036
    0.0012    0.0035    0.0093    0.0244    0.0639    0.0244    0.0093
    0.0004    0.0013    0.0035    0.0093    0.0244    0.0639    0.0244
    0.0002    0.0005    0.0014    0.0036    0.0093    0.0244    0.0639
    0.0001    0.0002    0.0005    0.0014    0.0035    0.0093    0.0243
    0.0000    0.0001    0.0002    0.0005    0.0013    0.0035    0.0091
    0.0000    0.0000    0.0001    0.0002    0.0004    0.0012    0.0030

  Columns 8 through 10

    0.0001    0.0000    0.0000
    0.0002    0.0001    0.0000
    0.0005    0.0002    0.0001
    0.0014    0.0005    0.0002
    0.0035    0.0013    0.0004
    0.0093    0.0035    0.0012
    0.0243    0.0091    0.0030
    0.0637    0.0239    0.0080
    0.0239    0.0625    0.0208
    0.0080    0.0208    0.0546

   5.0029e+12


function [Det,x] = InvDet(A)
%Inv det cu Gauss Piv Totala calc inv

%Synopsis:      x=InvDet(A)   

%Input:         A=matricea asociata sistemului
%               
%Output:        x=solutia sistemului

%-----Verificare matrice patratica
[n,m]=size(A);
if n~=m
    warning('Matricea nu este patratica');
    x=[];
    return
end


%construim matricea extinsa
A=[A,eye(n)];
Det=1;
for i=1:n
index(i)=i;
end
for k=1:n-1 
    max=-1;
    for i=k:n
        for j=k:n
            if abs(A(i,j))&gt;max;
                max=abs(A(i,j));
                p=i;m=j;
            end
        end
    end
    if A(p,m)==0 
        warning('Sist incomp. sau comp. nedet')
        x=[];
        return
    end
    if p~=k
      A([p,k],:)=A([k,p],:);
      Det=Det*(-1);
    end
      if m~=k
          A(:,[m,k])=A(:,[k,m]);
          index([m,k])=index([k,m]);
          Det=Det*(-1);
      end
      
      for l=k+1:n
          M(l,k)=A(l,k)/A(k,k);
          A(l,:)=A(l,:)-M(l,k)*A(k,:);
      end
     
end
 for i=1:n
     Det=Det*A(i,i);
 end
    if A(n,n)==0
        warning('Sist. incomp. sau comp. nedet.');
        return
    end
    for i=1:n
        y=subsDesc(A(:,1:n),A(:,n+i));
        for j=1:n
            x(index(j))=y(j);
        end
        A=[A,transpose(x)];
    end
    disp(A(:,(2*n+1):end));
    disp(Det);
   
 
end
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%%ex1 pct a

A=[0 1 1;2 1 5; 4 2 1]
b=[3;5;1]
fprintf('solutia este\n')
gaussPivTot(A,b);
type('gaussPivTot')

%%ex 1 pct b

A=[0 1 -2;1 -1 1; 1 0 -1]
b=[4;6;2]
fprintf('solutia este\n')
gaussPivTot(A,b);
type('gaussPivTot')

%%ex 2 varianta 5 

A=matrice(10)
b=solutie(10)
fprintf('solutia este\n')
gaussPivTot(A,b);
type('gaussPivTot')
%%ex 3

A=matrice(10)
fprintf('inversa e\n')
InvDet(A);
type('InvDet')


##### SOURCE END #####
--></body></html>